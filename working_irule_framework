when RULE_INIT {
    # Data patterns with proper regex capture
    set static::ip_regex {([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})}
    set static::email_regex {([^@]+)@([^@]+)\.([a-zA-Z]{2,})}

    # Code patterns
    set static::code_patterns(python) {
        "def "
        "class "
        "import "
        "from "
        "@"
        "if __name__"
        "try:"
        "raise "
        "async def"
        "yield"
    }

    set static::code_patterns(javascript) {
        "function "
        "const "
        "let "
        "class "
        "=>"
        "module.exports"
        "require"
        "import "
        "async function"
        "Promise"
    }

    set static::code_patterns(java) {
        "public class "
        "private "
        "protected "
        "package "
        "@Override"
        "new "
        "interface "
        "extends "
        "implements "
        "throw new"
    }

    set static::ai_messages(openai) {
        "gpt-"
        "davinci"
        "openai"
        "completions"
        "max_tokens"
        "temperature"
        "top_p"
    }

    set static::ai_messages(anthropic) {
        "claude"
        "anthropic"
        "x-api-key"
        "x-api-version"
    }

    set static::ai_messages(generic) {
        "messages"
        "content"
        "role"
        "system"
        "assistant"
        "Human:"
        "Assistant:"
        "you are"
        "act as"
        "pretend to be"
    }

    set static::ai_endpoints(openai) {
        chat.openai.com
        api.openai.com
        platform.openai.com
    }

    set static::ai_endpoints(anthropic) {
        claude.ai
        api.anthropic.com
    }
}

when CLIENT_ACCEPTED {
    set client_ip [IP::client_addr]
    set client_port [TCP::client_port]
    set local_port [TCP::local_port]
    set flow_key "${client_ip}_${client_port}_${local_port}"

    # Initialize with empty buffer
    table set -subtable "stream_buffer" $flow_key "" 300
}

when HTTP_REQUEST {
    set client_ip [IP::client_addr]
    set client_port [TCP::client_port]
    set local_port [TCP::local_port]
    set flow_key "${client_ip}_${client_port}_${local_port}"

    # Add X-Forwarded-For if present
    if { [HTTP::header exists "X-Forwarded-For"] } {
        append flow_key "_[HTTP::header "X-Forwarded-For"]"
    }

    # Store URI with shorter timeout
    table set -subtable "request_data" $flow_key [HTTP::uri] 300

    # Set smaller collect sizes to prevent memory issues
    switch -glob [string tolower [HTTP::header "Content-Type"]] {
        "*json*" - "*javascript*" - "*text*" - "*xml*" {
            HTTP::collect 524288
        }
        "*multipart*" {
            HTTP::collect 1048576
        }
        default {
            HTTP::collect 262144
        }
    }
}

when HTTP_REQUEST_DATA {
    set client_ip [IP::client_addr]
    set client_port [TCP::client_port]
    set local_port [TCP::local_port]
    set flow_key "${client_ip}_${client_port}_${local_port}"

    if { [HTTP::header exists "X-Forwarded-For"] } {
        append flow_key "_[HTTP::header "X-Forwarded-For"]"
    }

    # Get current chunk
    set chunk [HTTP::payload]

    if { [catch {
        # Keep only a window of data to prevent memory issues
        if { [table lookup -subtable "stream_buffer" $flow_key] ne "" } {
            set prev_data [string range [table lookup -subtable "stream_buffer" $flow_key] end-65536 end]
            set stream "${prev_data}${chunk}"
        } else {
            set stream $chunk
        }

        # Limit total size
        if { [string length $stream] > 262144 } {
            set stream [string range $stream end-262144 end]
        }

        # Store with short timeout
        table set -subtable "stream_buffer" $flow_key $stream 300

        array set detections {
            code_patterns {}
            ai_messages {}
            data_patterns {}
        }

        # Track unique code pattern detections
        array set detected_code_types {}
        foreach lang [array names static::code_patterns] {
            foreach pattern $static::code_patterns($lang) {
                if {[string first $pattern $stream] != -1} {
                    set detected_code_types($lang) 1
                    log local0. "Code pattern detected - Language: $lang"
                }
            }
        }
        # Add unique code detections to list
        foreach type [array names detected_code_types] {
            lappend detections(code_patterns) $type
        }

        # Track unique AI message detections
        array set detected_ai_types {}
        foreach type [array names static::ai_messages] {
            foreach pattern $static::ai_messages($type) {
                if {[string first $pattern $stream] != -1} {
                    set detected_ai_types($type) 1
                    log local0. "AI message detected - Type: $type"
                }
            }
        }
        # Add unique AI detections to list
        foreach type [array names detected_ai_types] {
            lappend detections(ai_messages) $type
        }

        # Track unique data pattern detections
        array set detected_data_types {}

        # Check for IP
        if {[regexp $static::ip_regex $stream -> ip1 ip2 ip3 ip4]} {
            if {$ip1 <= 255 && $ip2 <= 255 && $ip3 <= 255 && $ip4 <= 255} {
                set detected_data_types(ip_address) 1
                log local0. "IP address pattern detected"
            }
        }

        # Check for Email
        if {[regexp $static::email_regex $stream -> local domain tld]} {
            set detected_data_types(email) 1
            log local0. "Email pattern detected"
        }

        # Add unique data detections to list
        foreach type [array names detected_data_types] {
            lappend detections(data_patterns) $type
        }

        # Check AI endpoints
        set host [HTTP::host]
        foreach provider [array names static::ai_endpoints] {
            foreach endpoint $static::ai_endpoints($provider) {
                if {[string match "*$endpoint*" $host]} {
                    log local0. "AI endpoint detected: $provider"
                    HTTP::header insert "X-AI-Endpoint-Detection" "$provider"
                }
            }
        }

        # Check for code patterns first and redirect if found
        if { [llength $detections(code_patterns)] > 0 } {
            # Clean up before redirect
            catch { table delete -subtable "stream_buffer" $flow_key }

            # Log the detection and redirect
            log local0. "Code detected - redirecting - IP: $client_ip, Code: [join $detections(code_patterns) ","]"

            # Redirect to wompwompwomp.com
            HTTP::redirect "https://wompwompwomp.com"
            return
        }

        # Continue with other detections if no code was found
        if { [llength $detections(ai_messages)] > 0 || [llength $detections(data_patterns)] > 0 } {
            # Add detection headers
            if { [llength $detections(ai_messages)] > 0 } {
                HTTP::header insert "X-AI-Message-Detection" [join $detections(ai_messages) ","]
            }
            if { [llength $detections(data_patterns)] > 0 } {
                HTTP::header insert "X-Data-Detection" [join $detections(data_patterns) ","]
            }

            log local0. "Detection on [HTTP::uri] - IP: $client_ip, AI: [join $detections(ai_messages) ","], Data: [join $detections(data_patterns) ","]"

            switch -glob [HTTP::uri] {
                "*/internal/*" - "*/secure/*" - "*/confidential/*" {
                    HTTP::respond 403 content "Request blocked due to security policy"
                    return
                }
            }
        }
    } err] } {
        log local0. "Error processing request data: $err"
        catch { table delete -subtable "stream_buffer" $flow_key }
    }
}

when HTTP_RESPONSE {
    HTTP::collect 262144
}

when HTTP_RESPONSE_DATA {
    set client_ip [IP::client_addr]
    set client_port [TCP::client_port]
    set local_port [TCP::local_port]
    set flow_key "${client_ip}_${client_port}_${local_port}"

    if { [HTTP::header exists "X-Forwarded-For"] } {
        append flow_key "_[HTTP::header "X-Forwarded-For"]"
    }

    # Clean up all tables
    catch { table delete -subtable "stream_buffer" $flow_key }
    catch { table delete -subtable "request_data" $flow_key }
}
